<html lang="en">
<head>
  <title>xterm test</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>

  <style>
    .toolbar {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .toolbar button {
      font-size: 18px;
    }
    .toolbar #notice {
      margin-left: 10px;
      font-size: 16px;
      color: red;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <div>
      <button id="push">Push(appendable)</button>
      <button id="clear">Clear</button>

      <span id="notice"></span>
    </div>
    <div>
      <button id="reconnect">Reconnect</button>
    </div>
  </div>

  <div id="terminal"></div>
  <script>
    /* Initialize terminal */
    let term;
    const initTerminal = () => {
      if (term) term.dispose();
      term = new Terminal({
        cursorBlink: true,
        cols: 80,
        rows: 30,
      });
      term.open(document.getElementById('terminal'));
    };
    initTerminal();

    /* WS Connect */
    let ws;
    const messageStore = new (
      /* 원형 버퍼 부하 테스트 */
      class MessageStore {
        maxMessages = 1000;
        _messages = [];
        start = 0;
        end = 0;
        count = 0;

        addMessage(message) {
          this._messages[this.end] = message; // 메시지를 원형 버퍼의 끝 인덱스에 저장
          this.end = (this.end + 1) % this.maxMessages; // 끝 인덱스 순환

          if (this.count < this.maxMessages) {
            this.count++;
          } else {
            this.start = (this.start + 1) % this.maxMessages; // 시작 인덱스 순환
          }
        }
      }
    )();
    const connectWS = () => {
      ws = new WebSocket(`ws://${location.host}`);

      ws.onopen = () => {
        term.onData(data => {
          ws.send(data);
        });
      };
      const notice = document.getElementById('notice');
      ws.onmessage = ({ data }) => {
        if (data.startsWith('notice:')) {
          notice.textContent = data.replace('notice:', '');
          return;
        }
        term.write(data);
        messageStore.addMessage(data);
      };
      ws.onclose = () => {
        term.writeln('\r** Connection closed **');
      };
    };
    connectWS();

    /* Register button handlers */
    const pushBtn = document.getElementById('push');
    pushBtn.onclick = () => ws.send('action:push');

    const clearBtn = document.getElementById('clear');
    clearBtn.onclick = () => ws.send('action:clear');

    const reconnectBtn = document.getElementById('reconnect');
    reconnectBtn.onclick = () => {
      initTerminal();
      ws.close();
      connectWS();
    };
  </script>
</body>
</html>
